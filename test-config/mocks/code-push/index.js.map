{"version":3,"sources":["../../../src/@ionic-native-mocks/plugins/code-push/index.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,yBAAyB,CAAC;AACnD,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AA4N7C;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH;IAAkC,gCAAQ;IAA1C;;IAqFA,CAAC;IApFG;;;;;;OAMG;IACH,wCAAiB,GAAjB;QACI,IAAI,QAAuB,CAAC;QAC5B,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;OAIG;IACH,wCAAiB,GAAjB;QACI,IAAI,QAAuB,CAAC;QAC5B,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;;;;;;OASG;IACH,qCAAc,GAAd,UAAe,aAAsB;QACjC,IAAI,QAAwB,CAAC;QAC7B,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;;;;;OAQG;IACH,6CAAsB,GAAtB,cAAyC,MAAM,CAAC,CAAC,CAAC;IAAA,CAAC;IACnD;;;;OAIG;IACH,yCAAkB,GAAlB,cAAqC,MAAM,CAAC,CAAC,CAAC;IAAA,CAAC;IAC/C;;;;;;;;;;;;;;;;;;;;OAoBG;IACH,2BAAI,GAAJ,UAAK,WAAyB,EAAE,gBAAoD;QAChF,IAAI,QAAoB,CAAC;QACzB,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,UAAC,QAAuB;YAC7C,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACxB,QAAQ,CAAC,QAAQ,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACN,mBAAC;AAAD,CArFA,AAqFC,CArFiC,QAAQ,GAqFzC","file":"index.js","sourceRoot":"","sourcesContent":["import { CodePush } from '@ionic-native/code-push';\nimport { Observable } from 'rxjs/Observable';\nimport { Observer } from 'rxjs/Observer';\n\n/**\n * Defines a package. All fields are non-nullable, except when retrieving the currently running package on the first run of the app,\n * in which case only the appVersion is compulsory.\n *\n * !! THIS TYPE IS READ FROM NATIVE CODE AS WELL. ANY CHANGES TO THIS INTERFACE NEEDS TO BE UPDATED IN NATIVE CODE !!\n */\nexport interface IPackage {\n    deploymentKey: string;\n    description: string;\n    label: string;\n    appVersion: string;\n    isMandatory: boolean;\n    packageHash: string;\n    packageSize: number;\n    failedInstall: boolean;\n}\n/**\n * Defines a remote package, which represents an update package available for download.\n */\nexport interface IRemotePackage extends IPackage {\n    /**\n     * The URL at which the package is available for download.\n     */\n    downloadUrl: string;\n    /**\n     * Downloads the package update from the CodePush service.\n     *\n     * @param downloadSuccess Called with one parameter, the downloaded package information, once the download completed successfully.\n     * @param downloadError Optional callback invoked in case of an error.\n     * @param downloadProgress Optional callback invoked during the download process. It is called several times with one DownloadProgress parameter.\n     */\n    download(downloadSuccess: SuccessCallback<ILocalPackage>, downloadError?: ErrorCallback, downloadProgress?: SuccessCallback<DownloadProgress>): void;\n    /**\n     * Aborts the current download session, previously started with download().\n     *\n     * @param abortSuccess Optional callback invoked if the abort operation succeeded.\n     * @param abortError Optional callback invoked in case of an error.\n     */\n    abortDownload(abortSuccess?: SuccessCallback<void>, abortError?: ErrorCallback): void;\n}\n/**\n * Defines a local package.\n *\n * !! THIS TYPE IS READ FROM NATIVE CODE AS WELL. ANY CHANGES TO THIS INTERFACE NEEDS TO BE UPDATED IN NATIVE CODE !!\n */\nexport interface ILocalPackage extends IPackage {\n    /**\n     * The local storage path where this package is located.\n     */\n    localPath: string;\n    /**\n     * Indicates if the current application run is the first one after the package was applied.\n     */\n    isFirstRun: boolean;\n    /**\n     * Applies this package to the application. The application will be reloaded with this package and on every application launch this package will be loaded.\n     * On the first run after the update, the application will wait for a codePush.notifyApplicationReady() call. Once this call is made, the install operation is considered a success.\n     * Otherwise, the install operation will be marked as failed, and the application is reverted to its previous version on the next run.\n     *\n     * @param installSuccess Callback invoked if the install operation succeeded.\n     * @param installError Optional callback inovoked in case of an error.\n     * @param installOptions Optional parameter used for customizing the installation behavior.\n     */\n    install(installSuccess: SuccessCallback<InstallMode>, errorCallback?: ErrorCallback, installOptions?: InstallOptions): void;\n}\nexport interface Callback<T> {\n    (error: Error, parameter: T): void;\n}\nexport interface SuccessCallback<T> {\n    (result?: T): void;\n}\nexport interface ErrorCallback {\n    (error?: Error): void;\n}\n/**\n * Defines the possible result statuses of the window.codePush.sync operation.\n */\nexport declare enum SyncStatus {\n    /**\n     * The application is up to date.\n     */\n    UP_TO_DATE = 0,\n    /**\n     * An update is available, it has been downloaded, unzipped and copied to the deployment folder.\n     * After the completion of the callback invoked with SyncStatus.UPDATE_INSTALLED, the application will be reloaded with the updated code and resources.\n     */\n    UPDATE_INSTALLED = 1,\n    /**\n     * An optional update is available, but the user declined to install it. The update was not downloaded.\n     */\n    UPDATE_IGNORED = 2,\n    /**\n     * An error happened during the sync operation. This might be an error while communicating with the server, downloading or unziping the update.\n     * The console logs should contain more information about what happened. No update has been applied in this case.\n     */\n    ERROR = 3,\n    /**\n     * There is an ongoing sync in progress, so this attempt to sync has been aborted.\n     */\n    IN_PROGRESS = 4,\n    /**\n     * Intermediate status - the plugin is about to check for updates.\n     */\n    CHECKING_FOR_UPDATE = 5,\n    /**\n     * Intermediate status - a user dialog is about to be displayed. This status will be reported only if user interaction is enabled.\n     */\n    AWAITING_USER_ACTION = 6,\n    /**\n     * Intermediate status - the update package is about to be downloaded.\n     */\n    DOWNLOADING_PACKAGE = 7,\n    /**\n     * Intermediate status - the update package is about to be installed.\n     */\n    INSTALLING_UPDATE = 8,\n}\n/**\n * Defines the available install modes for updates.\n */\nexport declare enum InstallMode {\n    /**\n     * The update will be applied to the running application immediately. The application will be reloaded with the new content immediately.\n     */\n    IMMEDIATE = 0,\n    /**\n     * The update is downloaded but not installed immediately. The new content will be available the next time the application is started.\n     */\n    ON_NEXT_RESTART = 1,\n    /**\n     * The udpate is downloaded but not installed immediately. The new content will be available the next time the application is resumed or restarted, whichever event happends first.\n     */\n    ON_NEXT_RESUME = 2,\n}\n/**\n * Defines the install operation options.\n */\nexport interface InstallOptions {\n    /**\n     * Used to specify the InstallMode used for the install operation. This is optional and defaults to InstallMode.ON_NEXT_RESTART.\n     */\n    installMode?: InstallMode;\n    /**\n     * If installMode === ON_NEXT_RESUME, the minimum amount of time (in seconds) which needs to pass with the app in the background before an update install occurs when the app is resumed.\n     */\n    minimumBackgroundDuration?: number;\n    /**\n     * Used to specify the InstallMode used for the install operation if the update is mandatory. This is optional and defaults to InstallMode.IMMEDIATE.\n     */\n    mandatoryInstallMode?: InstallMode;\n}\n/**\n * Defines the sync operation options.\n */\nexport interface SyncOptions extends InstallOptions {\n    /**\n     * Optional boolean flag. If set, previous updates which were rolled back will be ignored. Defaults to true.\n     */\n    ignoreFailedUpdates?: boolean;\n    /**\n     * Used to enable, disable or customize the user interaction during sync.\n     * If set to false, user interaction will be disabled. If set to true, the user will be alerted or asked to confirm new updates, based on whether the update is mandatory.\n     * To customize the user dialog, this option can be set to a custom UpdateDialogOptions instance.\n     */\n    updateDialog?: boolean | UpdateDialogOptions;\n    /**\n     * Overrides the config.xml deployment key when checking for updates.\n     */\n    deploymentKey?: string;\n}\n/**\n * Defines the configuration options for the alert or confirmation dialog\n */\nexport interface UpdateDialogOptions {\n    /**\n     * If a mandatory update is available and this option is set, the message will be displayed to the user in an alert dialog before downloading and installing the update.\n     * The user will not be able to cancel the operation, since the update is mandatory.\n     */\n    mandatoryUpdateMessage?: string;\n    /**\n     * If an optional update is available and this option is set, the message will be displayed to the user in a confirmation dialog.\n     * If the user confirms the update, it will be downloaded and installed. Otherwise, the update update is not downloaded.\n     */\n    optionalUpdateMessage?: string;\n    /**\n     * The title of the dialog box used for interacting with the user in case of a mandatory or optional update.\n     * This title will only be used if at least one of mandatoryUpdateMessage or optionalUpdateMessage options are set.\n     */\n    updateTitle?: string;\n    /**\n     * The label of the confirmation button in case of an optional update.\n     */\n    optionalInstallButtonLabel?: string;\n    /**\n     * The label of the cancel button in case of an optional update.\n     */\n    optionalIgnoreButtonLabel?: string;\n    /**\n     * The label of the continue button in case of a mandatory update.\n     */\n    mandatoryContinueButtonLabel?: string;\n    /**\n     * Flag indicating if the update description provided by the CodePush server should be displayed in the dialog box appended to the update message.\n     */\n    appendReleaseDescription?: boolean;\n    /**\n     * Optional prefix to add to the release description.\n     */\n    descriptionPrefix?: string;\n}\n/**\n * Defines the format of the DownloadProgress object, used to send periodical update notifications on the progress of the update download.\n */\nexport interface DownloadProgress {\n    totalBytes: number;\n    receivedBytes: number;\n}\n/**\n * @name Code Push\n * @description\n * CodePush plugin for Cordova by Microsoft that supports iOS and Android.\n *\n * For more info, please see https://github.com/ksachdeva/ionic2-code-push-example\n *\n * @usage\n * ```typescript\n * import { CodePush } from '@ionic-native/code-push';\n *\n * constructor(private codePush: CodePush) { }\n *\n * ...\n *\n * // note - mostly error & completed methods of observable will not fire\n * // as syncStatus will contain the current state of the update\n * this.codePush.sync().subscribe((syncStatus) => console.log(syncStatus));\n *\n * const downloadProgress = (progress) => { console.log(`Downloaded ${progress.receivedBytes} of ${progress.totalBytes}`); }\n * this.codePush.sync({}, downloadProgress).subscribe((syncStatus) => console.log(syncStatus));\n *\n * ```\n */\nexport class CodePushMock extends CodePush {\n    /**\n     * Get the current package information.\n     *\n     * @param packageSuccess Callback invoked with the currently deployed package information.\n     * @param packageError Optional callback invoked in case of an error.\n     * @returns {Promise<ILocalPackage>}\n     */\n    getCurrentPackage(): Promise<ILocalPackage> {\n        let response: ILocalPackage;\n        return new Promise((resolve, reject) => {\n            resolve(response);\n        });\n    };\n    /**\n     * Gets the pending package information, if any. A pending package is one that has been installed but the application still runs the old code.\n     * This happends only after a package has been installed using ON_NEXT_RESTART or ON_NEXT_RESUME mode, but the application was not restarted/resumed yet.\n     * @returns {Promise<ILocalPackage>}\n     */\n    getPendingPackage(): Promise<ILocalPackage> {\n        let response: ILocalPackage;\n        return new Promise((resolve, reject) => {\n            resolve(response);\n        });\n    };\n    /**\n     * Checks with the CodePush server if an update package is available for download.\n     *\n     * @param querySuccess Callback invoked in case of a successful response from the server.\n     *                     The callback takes one RemotePackage parameter. A non-null package is a valid update.\n     *                     A null package means the application is up to date for the current native application version.\n     * @param queryError Optional callback invoked in case of an error.\n     * @param deploymentKey Optional deployment key that overrides the config.xml setting.\n     * @returns {Promise<IRemotePackage>}\n     */\n    checkForUpdate(deploymentKey?: string): Promise<IRemotePackage> {\n        let response: IRemotePackage;\n        return new Promise((resolve, reject) => {\n            resolve(response);\n        });\n    };\n    /**\n     * Notifies the plugin that the update operation succeeded and that the application is ready.\n     * Calling this function is required on the first run after an update. On every subsequent application run, calling this function is a noop.\n     * If using sync API, calling this function is not required since sync calls it internally.\n     *\n     * @param notifySucceeded Optional callback invoked if the plugin was successfully notified.\n     * @param notifyFailed Optional callback invoked in case of an error during notifying the plugin.\n     * @returns {Promise<any>}\n     */\n    notifyApplicationReady(): Promise<any> { return; };\n    /**\n     * Reloads the application. If there is a pending update package installed using ON_NEXT_RESTART or ON_NEXT_RESUME modes, the update\n     * will be immediately visible to the user. Otherwise, calling this function will simply reload the current version of the application.\n     * @returns {Promise<any>}\n     */\n    restartApplication(): Promise<any> { return; };\n    /**\n     * Convenience method for installing updates in one method call.\n     * This method is provided for simplicity, and its behavior can be replicated by using window.codePush.checkForUpdate(), RemotePackage's download() and LocalPackage's install() methods.\n     *\n     * The algorithm of this method is the following:\n     * - Checks for an update on the CodePush server.\n     * - If an update is available\n     *         - If the update is mandatory and the alertMessage is set in options, the user will be informed that the application will be updated to the latest version.\n     *           The update package will then be downloaded and applied.\n     *         - If the update is not mandatory and the confirmMessage is set in options, the user will be asked if they want to update to the latest version.\n     *           If they decline, the syncCallback will be invoked with SyncStatus.UPDATE_IGNORED.\n     *         - Otherwise, the update package will be downloaded and applied with no user interaction.\n     * - If no update is available on the server, or if a previously rolled back update is available and the ignoreFailedUpdates is set to true, the syncCallback will be invoked with the SyncStatus.UP_TO_DATE.\n     * - If an error occurs during checking for update, downloading or installing it, the syncCallback will be invoked with the SyncStatus.ERROR.\n     *\n     * @param syncCallback Optional callback to be called with the status of the sync operation.\n     * @param syncOptions Optional SyncOptions parameter configuring the behavior of the sync operation.\n     * @param downloadProgress Optional callback invoked during the download process. It is called several times with one DownloadProgress parameter.\n     * @returns {Observable<SyncStatus>}\n     *\n     */\n    sync(syncOptions?: SyncOptions, downloadProgress?: SuccessCallback<DownloadProgress>): Observable<SyncStatus> {\n        let response: SyncStatus;\n        return Observable.create((observer: Observer<any>) => {\n            observer.next(response);\n            observer.complete();\n        });\n    };\n}\n"]}