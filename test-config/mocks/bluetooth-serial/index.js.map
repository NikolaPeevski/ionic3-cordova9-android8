{"version":3,"sources":["../../../src/@ionic-native-mocks/plugins/bluetooth-serial/index.ts"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"","sourcesContent":["import { BluetoothSerial } from '@ionic-native/bluetooth-serial';\nimport { Observable } from 'rxjs/Observable';\nimport { Observer } from 'rxjs/Observer';\n\nexport class BluetoothSerialMock extends BluetoothSerial {\n    /**\n     * Connect to a Bluetooth device\n     * @param {string} macAddress_or_uuid Identifier of the remote device\n     * @returns {Observable<any>} Subscribe to connect, unsubscribe to disconnect.\n     */\n    connect(macAddress_or_uuid: string): Observable<any> {\n        return Observable.create( (observer: Observer<any>) => {\n            observer.next('');\n            observer.complete();\n        });\n    }\n    /**\n     * Connect insecurely to a Bluetooth device\n     * @param {string} macAddress Identifier of the remote device\n     * @returns {Observable<any>} Subscribe to connect, unsubscribe to disconnect.\n     */\n    connectInsecure(macAddress: string): Observable<any> {\n        return Observable.create( (observer: Observer<any>) => {\n            observer.next('');\n            observer.complete();\n        });\n    }\n    /**\n     * Disconnect from the connected device\n     * @returns {Promise<any>}\n     */\n    disconnect(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    }\n    /**\n     * Writes data to the serial port\n     * @param {any} data ArrayBuffer of data\n     * @returns {Promise<any>} returns a promise when data has been written\n     */\n    write(data: any): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    }\n    /**\n     * Gets the number of bytes of data available\n     * @returns {Promise<any>} returns a promise that contains the available bytes\n     */\n    available(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    }\n    /**\n     * Reads data from the buffer\n     * @returns {Promise<any>} returns a promise with data from the buffer\n     */\n    read(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    }\n    /**\n     * Reads data from the buffer until it reaches a delimiter\n     * @param {string} delimiter string that you want to search until\n     * @returns {Promise<any>} returns a promise\n     */\n    readUntil(delimiter: string): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    }\n    /**\n     * Subscribe to be notified when data is received\n     * @param {string} delimiter the string you want to watch for\n     * @returns {Observable<any>} returns an observable.\n     */\n    subscribe(delimiter: string): Observable<any> {\n        return Observable.create( (observer: Observer<any>) => {\n            observer.next('');\n            observer.complete();\n        });\n    }\n    /**\n     * Subscribe to be notified when data is received\n     * @returns {Observable<any>} returns an observable\n     */\n    subscribeRawData(): Observable<any> {\n        return Observable.create( (observer: Observer<any>) => {\n            observer.next('');\n            observer.complete();\n        });\n    }\n    /**\n     * Clears data in buffer\n     * @returns {Promise<any>} returns a promise when completed\n     */\n    clear(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    }\n    /**\n     * Lists bonded devices\n     * @returns {Promise<any>} returns a promise\n     */\n    list(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    }\n    /**\n     * Reports if bluetooth is enabled\n     * @returns {Promise<any>} returns a promise\n     */\n    isEnabled(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    }\n    /**\n     * Reports the connection status\n     * @returns {Promise<any>} returns a promise\n     */\n    isConnected(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    }\n    /**\n     * Reads the RSSI from the connected peripheral\n     * @returns {Promise<any>} returns a promise\n     */\n    readRSSI(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    }\n    /**\n     * Show the Bluetooth settings on the device\n     * @returns {Promise<any>} returns a promise\n     */\n    showBluetoothSettings(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    }\n    /**\n     * Enable Bluetooth on the device\n     * @returns {Promise<any>} returns a promise\n     */\n    enable(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    }\n    /**\n     * Discover unpaired devices\n     * @returns {Promise<any>} returns a promise\n     */\n    discoverUnpaired(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    }\n    /**\n     * Subscribe to be notified on Bluetooth device discovery. Discovery process must be initiated with the `discoverUnpaired` function.\n     * @returns {Observable<any>} Returns an observable\n     */\n    setDeviceDiscoveredListener(): Observable<any> {\n        return Observable.create( (observer: Observer<any>) => {\n            observer.next('');\n            observer.complete();\n        });\n    }\n    /**\n     * Sets the human readable device name that is broadcasted to other devices\n     * @param {string} newName Desired name of device\n     */\n    setName(newName: string): void { };\n    /**\n     * Makes the device discoverable by other devices\n     * @param {number} discoverableDuration Desired number of seconds device should be discoverable for\n     */\n    setDiscoverable(discoverableDuration: number): void { };\n}\n"]}