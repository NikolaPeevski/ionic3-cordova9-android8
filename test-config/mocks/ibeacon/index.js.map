{"version":3,"sources":["../../../src/@ionic-native-mocks/plugins/ibeacon/index.ts"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"","sourcesContent":["import { IBeacon } from '@ionic-native/ibeacon';\nimport { Observable } from 'rxjs/Observable';\n\nexport interface Beacon {\n    /**\n     * The physical device's identifier.\n     */\n    uuid: string;\n    /**\n     * The beacon's major identifier number.\n     */\n    major: number;\n    /**\n     * The beacon's minor identifier number.\n     */\n    minor: number;\n    /**\n     * The proximity of the beacon relative to the phone.\n     *\n     * Possible options are:\n     * ProximityImmediate\n     * ProximityNear\n     * ProximityFar\n     * ProximityUnknown\n     */\n    proximity: 'ProximityImmediate' | 'ProximityNear' | 'ProximityFar' | 'ProximityUnknown';\n    /**\n     * Transmission Power of the beacon. A constant emitted by the beacon which indicates what's the expected RSSI at a distance of 1 meter to the beacon.\n     */\n    tx: number;\n    /**\n     * Received Signal Strength Indicator. The strength of the beacon's signal when it reaches the device.\n     *  RSSI ranges from aprox -26 (a few inches) to -100 (40-50 m distance).\n     */\n    rssi: number;\n    /**\n     * The accuracy of the ranging.\n     */\n    accuracy: number;\n}\nexport interface BeaconRegion {\n    /**\n     * A unique identifier for this region.\n     */\n    identifier: string;\n    /**\n     * The the beacon identifier the device will \"watch\" for. Many beacons can share the same uuid.\n     */\n    uuid: string;\n    /**\n     * The beacon's major identifier number. Optional, of nothing is supplied\n     * the plugin will treat it as a wildcard.\n     */\n    major?: number;\n    /**\n     * The beacon's minor identifier number. Optional, of nothing is supplied\n     * the plugin will treat it as a wildcard.\n     */\n    minor?: number;\n    /**\n     * If set to true the device will scan for beacons and determine region state anytime\n     * the device's screen is turned on or off. Useful for debugging.\n     */\n    notifyEntryStateOnDisplay?: boolean;\n}\nexport interface CircularRegion {\n    /**\n     * A unique identifier for this region.\n     */\n    identifier: string;\n    /**\n     * The latitude of this region.\n     */\n    latitude: number;\n    /**\n     * The longitude of this region.\n     */\n    longitude: number;\n    /**\n     * The radius of the geofence for this region.\n     */\n    radius: number;\n}\nexport declare type Region = BeaconRegion | CircularRegion;\nexport interface IBeaconPluginResult {\n    /**\n     * The name of the delegate function that produced the PluginResult object.\n     */\n    eventType: string;\n    /**\n     * The region that triggered the event.\n     */\n    region: Region;\n    /**\n     * An array of beacon objects\n     */\n    beacons: Beacon[];\n    /**\n     * The status of the location permission for iOS.\n     */\n    authorizationStatus: string;\n    /**\n     * The state of the phone in relation to the region. Inside/outside for example.\n     */\n    state: 'CLRegionStateInside' | 'CLRegionStateOutside';\n    /**\n     * Error message, used only with monitoringDidFailForRegionWithError delegate.\n     */\n    error: string;\n}\nexport interface IBeaconDelegate {\n    /**\n     * An observable that publishes information about the location permission authorization status.\n     *\n     * @returns {Observable<string>} Returns a string.\n     */\n    didChangeAuthorizationStatus(): Observable<string>;\n    /**\n     * An Observable that publishes event data to it's subscribers\n     * when the native layer is able to determine the device's state.\n     *\n     * This event is called when the phone begins starts monitoring,\n     * when requestStateForRegion is called, etc.\n     *\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\n     */\n    didDetermineStateForRegion(): Observable<IBeaconPluginResult>;\n    /**\n     * An Observable that publishes event data to it's subscribers\n     * when the phone enters a region that it was asked to monitor.\n     *\n     * If the user has given the app Always-Location permission, this function\n     *  will be called even when the app is not running on iOS.\n     * The app will run silently in the background for a small amount of time.\n     *\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\n     */\n    didEnterRegion(): Observable<IBeaconPluginResult>;\n    /**\n     * An Observable that publishes event data to it's subscribers\n     * when the phone exits a region that it was asked to monitor.\n     *\n     * If the user has given the app Always-Location permission, this function\n     *  will be called even when the app is not running on iOS.\n     * The app will run silently in the background for a small amount of time.\n     *\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\n     */\n    didExitRegion(): Observable<IBeaconPluginResult>;\n    /**\n     * An Observable that publishes event data to it's subscribers\n     *  each time that the device ranges beacons. Modern Android and iOS devices range\n     * aproximately once per second.\n     *\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\n     */\n    didRangeBeaconsInRegion(): Observable<IBeaconPluginResult>;\n    /**\n     * An Observable that publishes event data to it's subscribers\n     *  when the device begins monitoring a region.\n     *\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\n     */\n    didStartMonitoringForRegion(): Observable<IBeaconPluginResult>;\n    /**\n     * An Observable that publishes event data to it's subscribers\n     *  when the device fails to monitor a region.\n     *\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\n     */\n    monitoringDidFailForRegionWithError(): Observable<IBeaconPluginResult>;\n    /**\n     * An Observable that publishes event data to it's subscribers\n     *  when the device begins advertising as an iBeacon.\n     *\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\n     */\n    peripheralManagerDidStartAdvertising(): Observable<IBeaconPluginResult>;\n    /**\n     * An Observable that publishes event data to it's subscribers\n     * when the state of the peripheral manager's state updates.\n     *\n     *\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\n     */\n    peripheralManagerDidUpdateState(): Observable<IBeaconPluginResult>;\n}\n\nexport class IBeaconMock extends IBeacon {\n    /**\n     * Instances of this class are delegates between the {@link LocationManager} and\n     * the code that consumes the messages generated on in the native layer.\n     *\n     * @returns {IBeaconDelegate} An instance of the type {@type Delegate}.\n     */\n    Delegate(): IBeaconDelegate {\n        let response: IBeaconDelegate;\n        return response;\n    };\n    /**\n     * Creates a new BeaconRegion\n     *\n     * @param {String} identifier @see {CLRegion}\n     * @param {String} uuid The proximity ID of the beacon being targeted.\n     * This value must not be blank nor invalid as a UUID.\n     * @param {Number} major The major value that you use to identify one or more beacons.\n     * @param {Number} minor The minor value that you use to identify a specific beacon.\n     * @param {BOOL} notifyEntryStateOnDisplay\n     *\n     * @returns {BeaconRegion} Returns the BeaconRegion that was created\n     */\n    BeaconRegion(identifer: string, uuid: string, major?: number, minor?: number, notifyEntryStateOnDisplay?: boolean): BeaconRegion {\n        let response: BeaconRegion;\n        return response;\n    };\n    /**\n     * @returns {IBeaconDelegate} Returns the IBeaconDelegate\n     */\n    getDelegate(): IBeaconDelegate {\n        let response: IBeaconDelegate;\n        return response;\n    };\n    /**\n     * @param {IBeaconDelegate} delegate An instance of a delegate to register with the native layer.\n     *\n     * @returns {IBeaconDelegate} Returns the IBeaconDelegate\n     */\n    setDelegate(delegate: IBeaconDelegate): IBeaconDelegate {\n        let response: IBeaconDelegate;\n        return response;\n    };\n    /**\n     * Signals the native layer that the client side is ready to consume messages.\n     * Readiness here means that it has a {IBeaconDelegate} set by the consumer javascript\n     * code.\n     *\n     * The {LocationManager.setDelegate()} will implicitly call this method as well,\n     * therefore the only case when you have to call this manually is if you don't\n     * wish to specify a {IBeaconDelegate} of yours.\n     *\n     * The purpose of this signaling mechanism is to make the events work when the\n     * app is being woken up by the Operating System to give it a chance to handle\n     * region monitoring events for example.\n     *\n     * If you don't set a {IBeaconDelegate} and don't call this method manually, an error\n     * message get emitted in the native runtime and the DOM as well after a certain\n     * period of time.\n     *\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\n     * native layer acknowledged the request and started to send events.\n     */\n    onDomDelegateReady(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Determines if bluetooth is switched on, according to the native layer.\n     * @returns {Promise<boolean>} Returns a promise which is resolved with a {Boolean}\n     * indicating whether bluetooth is active.\n     */\n    isBluetoothEnabled(): Promise<boolean> {\n        let response: boolean = true;\n        return new Promise((resolve, reject) => {\n            resolve(response);\n        });\n    };\n    /**\n     * Enables Bluetooth using the native Layer. (ANDROID ONLY)\n     *\n     * @returns {Promise<any>} Returns a promise which is resolved when Bluetooth\n     * could be enabled. If not, the promise will be rejected with an error.\n     */\n    enableBluetooth(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Disables Bluetooth using the native Layer. (ANDROID ONLY)\n     *\n     * @returns {Promise<any>} Returns a promise which is resolved when Bluetooth\n     * could be enabled. If not, the promise will be rejected with an error.\n     */\n    disableBluetooth(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Start monitoring the specified region.\n     *\n     * If a region of the same type with the same identifier is already being\n     * monitored for this application,\n     * it will be removed from monitoring. For circular regions, the region\n     * monitoring service will prioritize\n     * regions by their size, favoring smaller regions over larger regions.\n     *\n     * This is done asynchronously and may not be immediately reflected in monitoredRegions.\n     *\n     * @param {Region} region An instance of {Region} which will be monitored\n     * by the operating system.\n     *\n     * @returns {Promise<string>} Returns a promise which is resolved as soon as the\n     * native layer acknowledged the dispatch of the monitoring request.\n     */\n    startMonitoringForRegion(region: BeaconRegion): Promise<string> {\n        let response: string = '';\n        return new Promise((resolve, reject) => {\n            resolve(response);\n        });\n    };\n    /**\n     * Stop monitoring the specified region.  It is valid to call\n     * stopMonitoringForRegion: for a region that was registered for monitoring\n     * with a different location manager object, during this or previous\n     * launches of your application.\n     *\n     * This is done asynchronously and may not be immediately reflected in monitoredRegions.\n     *\n     * @param {Region} region An instance of {Region} which will be monitored\n     * by the operating system.\n     *\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\n     * native layer acknowledged the dispatch of the request to stop monitoring.\n     */\n    stopMonitoringForRegion(region: BeaconRegion): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Request state the for specified region. When result is ready\n     * didDetermineStateForRegion is triggered. This can be any region,\n     * also those which is not currently monitored.\n     *\n     * This is done asynchronously and may not be immediately reflected in monitoredRegions.\n     *\n     * @param {Region} region An instance of {Region} which will be monitored\n     * by the operating system.\n     *\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\n     * native layer acknowledged the dispatch of the request to stop monitoring.\n     */\n    requestStateForRegion(region: Region): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Start ranging the specified beacon region.\n     *\n     * If a region of the same type with the same identifier is already being\n     * monitored for this application, it will be removed from monitoring.\n     *\n     * This is done asynchronously and may not be immediately reflected in rangedRegions.\n     *\n     * @param {Region} region An instance of {BeaconRegion} which will be monitored\n     * by the operating system.\n     *\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\n     * native layer acknowledged the dispatch of the monitoring request.\n     */\n    startRangingBeaconsInRegion(region: BeaconRegion): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Stop ranging the specified region.  It is valid to call\n     * stopMonitoringForRegion: for a region that was registered for ranging\n     * with a different location manager object, during this or previous\n     * launches of your application.\n     *\n     * This is done asynchronously and may not be immediately reflected in rangedRegions.\n     *\n     * @param {Region} region An instance of {BeaconRegion} which will be monitored\n     * by the operating system.\n     *\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\n     * native layer acknowledged the dispatch of the request to stop monitoring.\n     */\n    stopRangingBeaconsInRegion(region: BeaconRegion): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Queries the native layer to determine the current authorization in effect.\n     *\n     * @returns {Promise<IBeaconPluginResult>} Returns a promise which is resolved with the\n     * requested authorization status.\n     */\n    getAuthorizationStatus(): Promise<IBeaconPluginResult> {\n        let response: IBeaconPluginResult;\n        return new Promise((resolve, reject) => {\n            resolve(response);\n        });\n    };\n    /**\n     * For iOS 8 and above only. The permission model has changed by Apple in iOS 8, making it necessary for apps to\n     * explicitly request permissions via methods like these:\n     * <a href=\"https://developer.apple.com/library/prerelease/iOS/documentation/CoreLocation/Reference/CLLocationManager_Class/index.html#//apple_ref/occ/instm/CLLocationManager/requestWhenInUseAuthorization\">requestWhenInUseAuthorization</a>\n     * <a href=\"https://developer.apple.com/library/prerelease/iOS/documentation/CoreLocation/Reference/CLLocationManager_Class/index.html#//apple_ref/occ/instm/CLLocationManager/requestAlwaysAuthorization\">requestAlwaysAuthorization</a>\n     *\n     * If you are using this plugin on Android devices only, you will never have to use this, nor {@code requestAlwaysAuthorization}\n     * @returns {Promise<any>} Returns a promise that is resolved when the request dialog is shown.\n     */\n    requestWhenInUseAuthorization(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * See the documentation of {@code requestWhenInUseAuthorization} for further details.\n     *\n     * @returns {Promise<any>} Returns a promise which is resolved when the native layer\n     * shows the request dialog.\n     */\n    requestAlwaysAuthorization(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     *\n     * @returns {Promise<Region[]>} Returns a promise which is resolved with an {Array}\n     * of {Region} instances that are being monitored by the native layer.\n     */\n    getMonitoredRegions(): Promise<Region[]> {\n        let response: Array<Region> = [];\n        return new Promise((resolve, reject) => {\n            resolve(response);\n        });\n    };\n    /**\n     *\n     * @returns {Promise<Region[]>} Returns a promise which is resolved with an {Array}\n     * of {Region} instances that are being ranged by the native layer.\n     */\n    getRangedRegions(): Promise<Region[]> {\n        let response: Array<Region> = [];\n        return new Promise((resolve, reject) => {\n            resolve(response);\n        });\n    };\n    /**\n     * Determines if ranging is available or not, according to the native layer.\n     * @returns {Promise<boolean>} Returns a promise which is resolved with a {Boolean}\n     * indicating whether ranging is available or not.\n     */\n    isRangingAvailable(): Promise<boolean> {\n        let response: boolean = true;\n        return new Promise((resolve, reject) => {\n            resolve(response);\n        });\n    };\n    /**\n     * Determines if region type is supported or not, according to the native layer.\n     *\n     * @param {Region} region An instance of {Region} which will be checked\n     * by the operating system.\n     *\n     * @returns {Promise<boolean>} Returns a promise which is resolved with a {Boolean}\n     * indicating whether the region type is supported or not.\n     */\n    isMonitoringAvailableForClass(region: Region): Promise<boolean> {\n        let response: boolean = true;\n        return new Promise((resolve, reject) => {\n            resolve(response);\n        });\n    };\n    /**\n     * Start advertising the specified region.\n     *\n     * If a region a different identifier is already being advertised for\n     * this application, it will be replaced with the new identifier.\n     *\n     * This call will accept a valid beacon even when no BlueTooth is available,\n     * and will start when BlueTooth is powered on. See {IBeaconDelegate.}\n     *\n     * @param {Region} region An instance of {Region} which will be advertised\n     * by the operating system.\n     * @param {Integer} measuredPower: Optional parameter, if left empty, the device will\n     * use it's own default value.\n     *\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\n     * native layer acknowledged the dispatch of the advertising request.\n     */\n    startAdvertising(region: Region, measuredPower?: number): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Stop advertising as a beacon.\n     *\n     * This is done asynchronously and may not be immediately reflected in isAdvertising.\n     *\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\n     * native layer acknowledged the dispatch of the request to stop advertising.\n     */\n    stopAdvertising(region: Region): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Determines if advertising is available or not, according to the native layer.\n     * @returns {Promise<any>} Returns a promise which is resolved with a {Boolean}\n     * indicating whether advertising is available or not.\n     */\n    isAdvertisingAvailable(): Promise<boolean> {\n        let response: boolean = true;\n        return new Promise((resolve, reject) => {\n            resolve(response);\n        });\n    };\n    /**\n     * Determines if advertising is currently active, according to the native layer.\n     * @returns {Promise<any>} Returns a promise which is resolved with a {Boolean}\n     * indicating whether advertising is active.\n     */\n    isAdvertising(): Promise<boolean> {\n        let response: boolean = true;\n        return new Promise((resolve, reject) => {\n            resolve(response);\n        });\n    };\n    /**\n     * Disables debug logging in the native layer. Use this method if you want\n     * to prevent this plugin from writing to the device logs.\n     *\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\n     * native layer has set the logging level accordingly.\n     */\n    disableDebugLogs(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Enables the posting of debug notifications in the native layer. Use this method if you want\n     * to allow the plugin the posting local notifications.\n     * This can be very helpful when debugging how to apps behave when launched into the background.\n     *\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\n     * native layer has set the flag to enabled.\n     */\n    enableDebugNotifications(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Disables the posting of debug notifications in the native layer. Use this method if you want\n     * to prevent the plugin from posting local notifications.\n     *\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\n     * native layer has set the flag to disabled.\n     */\n    disableDebugNotifications(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Enables debug logging in the native layer. Use this method if you want\n     * a debug the inner workings of this plugin.\n     *\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\n     * native layer has set the logging level accordingly.\n     */\n    enableDebugLogs(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Appends the provided [message] to the device logs.\n     * Note: If debug logging is turned off, this won't do anything.\n     *\n     * @param {String} message The message to append to the device logs.\n     *\n     * @returns {Promise<any>} Returns a promise which is resolved with the log\n     * message received by the native layer for appending. The returned message\n     * is expected to be equivalent to the one provided in the original call.\n     */\n    appendToDeviceLog(message: string): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n}\n"]}