{"version":3,"sources":["../../../src/@ionic-native-mocks/plugins/geofence/index.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,wBAAwB,CAAC;AAClD,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAG7C;IAAkC,gCAAQ;IAA1C;;IA4FA,CAAC;IAtFG;;;OAGG;IACH,0CAAmB,GAAnB;QACI,IAAI,QAAa,CAAC;QAClB,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,UAAC,QAAuB;YAC7C,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACxB,QAAQ,CAAC,QAAQ,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;OAIG;IACH,iCAAU,GAAV;QACI,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,EAAE,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;OAIG;IACH,kCAAW,GAAX,UAAY,SAAiC;QACzC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,EAAE,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;;OAKG;IACH,6BAAM,GAAN,UAAO,UAAkC;QACrC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,EAAE,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;OAIG;IACH,gCAAS,GAAT;QACI,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,EAAE,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;OAIG;IACH,iCAAU,GAAV;QACI,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,EAAE,CAAC,CAAC;QAChB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;OAIG;IACH,2CAAoB,GAApB;QACI,IAAI,QAAa,CAAC;QAClB,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,UAAC,QAAuB;YAC7C,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACxB,QAAQ,CAAC,QAAQ,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;OAIG;IACH,4CAAqB,GAArB;QACI,IAAI,QAAa,CAAC;QAClB,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,UAAC,QAAuB;YAC7C,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACxB,QAAQ,CAAC,QAAQ,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACN,mBAAC;AAAD,CA5FA,AA4FC,CA5FiC,QAAQ,GA4FzC","file":"index.js","sourceRoot":"","sourcesContent":["import { Geofence } from '@ionic-native/geofence';\nimport { Observable } from 'rxjs/Observable';\nimport { Observer } from 'rxjs/Observer';\n\nexport class GeofenceMock extends Geofence {\n    TransitionType: {\n        ENTER: number;\n        EXIT: number;\n        BOTH: number;\n    };\n    /**\n     * Subscribe to get notified when a transition is received\n     * @return {Observable<any>}\n     */\n    onTrasitionReceived(): Observable<any> {\n        let response: any;\n        return Observable.create((observer: Observer<any>) => {\n            observer.next(response);\n            observer.complete();\n        });\n    };\n    /**\n     * Initializes the plugin. User will be prompted to allow the app to use location and notifications.\n     *\n     * @returns {Promise<any>}\n     */\n    initialize(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Adds a new geofence or array of geofences. For geofence object, see above.\n     *\n     * @returns {Promise<any>}\n     */\n    addOrUpdate(geofences: Object | Array<Object>): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Removes a geofence or array of geofences. `geofenceID` corresponds to one or more IDs specified when the\n     * geofence was created.\n     *\n     * @returns {Promise<any>}\n     */\n    remove(geofenceId: string | Array<string>): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Removes all geofences.\n     *\n     * @returns {Promise<any>}\n     */\n    removeAll(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            resolve();\n        });\n    };\n    /**\n     * Returns an array of geofences currently being monitored.\n     *\n     * @returns {Promise<Array<string>>}\n     */\n    getWatched(): Promise<string> {\n        return new Promise((resolve, reject) => {\n            resolve('');\n        });\n    };\n    /**\n     * Called when a geofence is crossed in the direction specified by `TransitType`.\n     *\n     * @returns {Observable<any>}\n     */\n    onTransitionReceived(): Observable<any> {\n        let response: any;\n        return Observable.create((observer: Observer<any>) => {\n            observer.next(response);\n            observer.complete();\n        });\n    };\n    /**\n     * Called when the user clicks a geofence notification. iOS and Android only.\n     *\n     * @returns {Observable<any>}\n     */\n    onNotificationClicked(): Observable<any> {\n        let response: any;\n        return Observable.create((observer: Observer<any>) => {\n            observer.next(response);\n            observer.complete();\n        });\n    };\n}\n"]}